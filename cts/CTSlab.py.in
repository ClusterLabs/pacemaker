#!@PYTHON@

'''CTS: Cluster Testing System: Lab environment module


 '''

__copyright__='''
Copyright (C) 2001 Alan Robertson <alanr@unix.sh>
Licensed under the GNU GPL.
'''

#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

from UserDict import UserDict
import sys, time, types, syslog, whrandom, os, struct, string
from CTS  import ClusterManager
from CM_hb import HeartbeatCM
from socket import gethostbyname_ex

class ResetMechanism:
    def reset(self, node):
        raise ValueError("Abstract class member (reset)")

class Stonith(ResetMechanism):
    def __init__(self, sttype="ssh", parm="foobar"
        ,        path="@sbindir@/stonith"):
        self.pathname=path
        self.configstring=parm
        self.stonithtype=sttype

    def reset(self, node):
        cmdstring = "%s -t '%s' -p '%s' '%s' 2>/dev/null" % (self.pathname
        ,        self.stonithtype, self.configstring, node)
        return (os.system(cmdstring) == 0)

class Logger:
    TimeFormat = "%Y/%m/%d_%H:%M:%S\t"

    def __call__(self, lines):
        raise ValueError("Abstract class member (__call__)")

class SysLog(Logger):
    # http://docs.python.org/lib/module-syslog.html
    defaultsource="CTS"
    defaultfacility= syslog.LOG_LOCAL7
    map = {
            "kernel":	syslog.LOG_KERN,
            "user":	syslog.LOG_USER,
            "mail":	syslog.LOG_MAIL,
            "daemon":	syslog.LOG_MAIL,
            "auth":	syslog.LOG_AUTH,
            "lpr":	syslog.LOG_LPR,
            "news":	syslog.LOG_NEWS,
            "uucp":	syslog.LOG_UUCP,
            "cron":	syslog.LOG_CRON,
            "local0":	syslog.LOG_LOCAL0,
            "local1":	syslog.LOG_LOCAL1,
            "local2":	syslog.LOG_LOCAL2,
            "local3":	syslog.LOG_LOCAL3,
            "local4":	syslog.LOG_LOCAL4,
            "local5":	syslog.LOG_LOCAL5,
            "local6":	syslog.LOG_LOCAL6,
            "local7":	syslog.LOG_LOCAL7,
    }
    def __init__(self, labinfo):

        if labinfo.has_key("syslogsource"):
            self.source=labinfo["syslogsource"]
        else:
            self.source=SysLog.defaultsource

        if labinfo.has_key("SyslogFacility"):
            self.facility=labinfo["SyslogFacility"]
            if SysLog.map.has_key(self.facility):
              self.facility=SysLog.map[self.facility]
        else:
            self.facility=SysLog.defaultfacility

        syslog.openlog(self.source, 0, self.facility)

    def setfacility(self, facility):
        self.facility = facility
        if SysLog.map.has_key(self.facility):
          self.facility=SysLog.map[self.facility]
        syslog.closelog()
        syslog.openlog(self.source, 0, self.facility)
        

    def __call__(self, lines):
        if isinstance(lines, types.StringType):
            syslog.syslog(lines)
        else:
            for line in lines:
                syslog.syslog(line)

    def name(self):
        return "Syslog"

class StdErrLog(Logger):

    def __init__(self, labinfo):
        pass

    def __call__(self, lines):
        t = time.strftime(Logger.TimeFormat, time.localtime(time.time()))  
        if isinstance(lines, types.StringType):
            sys.__stderr__.writelines([t, lines, "\n"])
        else:
            for line in lines:
                sys.__stderr__.writelines([t, line, "\n"])
        sys.__stderr__.flush()

    def name(self):
        return "StdErrLog"

class FileLog(Logger):
    def __init__(self, labinfo, filename=None):

        if filename == None:
            filename=labinfo["logfile"]
        
        self.logfile=filename

    def __call__(self, lines):

        fd = open(self.logfile, "a")
        t = time.strftime(Logger.TimeFormat, time.localtime(time.time()))  

        if isinstance(lines, types.StringType):
            fd.writelines([t, lines, "\n"])
        else:
            for line in lines:
                fd.writelines([t, line, "\n"])
        fd.close()

    def name(self):
        return "FileLog"

class CtsLab(UserDict):
    '''This class defines the Lab Environment for the Cluster Test System.
    It defines those things which are expected to change from test
    environment to test environment for the same cluster manager.

    It is where you define the set of nodes that are in your test lab
    what kind of reset mechanism you use, etc.

    This class is derived from a UserDict because we hold many
    different parameters of different kinds, and this provides
    provide a uniform and extensible interface useful for any kind of
    communication between the user/administrator/tester and CTS.

    At this point in time, it is the intent of this class to model static
    configuration and/or environmental data about the environment which
    doesn't change as the tests proceed.

    Well-known names (keys) are an important concept in this class.
    The HasMinimalKeys member function knows the minimal set of
    well-known names for the class.

    The following names are standard (well-known) at this time:

        nodes           An array of the nodes in the cluster
        reset           A ResetMechanism object
        logger          An array of objects that log strings...
        CMclass         The type of ClusterManager we are running
                        (This is a class object, not a class instance)
        RandSeed        Random seed.  It is a triple of bytes. (optional)
        HAdir           Base directory for HA installation

    The CTS code ignores names it doesn't know about/need.
    The individual tests have access to this information, and it is
    perfectly acceptable to provide hints, tweaks, fine-tuning
    directions or other information to the tests through this mechanism.
    '''

    def __init__(self, nodes):
        self.data = {}
        self["nodes"] = nodes
        self.MinimalKeys=["nodes", "reset", "logger", "CMclass", "HAdir"]

    def HasMinimalKeys(self):
        'Return TRUE if our object has the minimal set of keys/values in it'
        result = 1
        for key in self.MinimalKeys:
            if not self.has_key(key):
                result = None
        return result

    def SupplyDefaults(self): 
        if not self.has_key("logger"):
            self["logger"] = (SysLog(self), StdErrLog(self))
        if not self.has_key("reset"):
            self["reset"] = Stonith()
        if not self.has_key("CMclass"):
            self["CMclass"] = HeartbeatCM
        if not self.has_key("HAdir"):
            self["HAdir"] = "@sysconfdir@/ha.d"
        if not self.has_key("LogFileName"):
            self["LogFileName"] = "/var/log/ha-log"

        #
        #  Now set up our random number generator...
        #
        self.RandomGen = whrandom.whrandom()

        #  Get a random seed for the random number generator.

        if self.has_key("RandSeed"):
            randseed = self["RandSeed"]
        else:
            f=open("/dev/urandom", "r")
            string=f.read(3)
            f.close()
            randseed=struct.unpack("BBB", string)

        self.log("Random seed is: " + str(randseed))
        self.randseed=randseed

        self.RandomGen.seed(randseed[0], randseed[1], randseed[2]) 

    def log(self, args):
        "Log using each of the supplied logging methods"
        for logfcn in self._logfunctions:
            logfcn(string.strip(args))

    def debug(self, args):
        "Log using each of the supplied logging methods"
        for logfcn in self._logfunctions:
            if logfcn.name() != "StdErrLog":
                logfcn(string.strip(args))

    def __setitem__(self, key, value):
        '''Since this function gets called whenever we modify the
        dictionary (object), we can (and do) validate those keys that we
        know how to validate.  For the most part, we know how to validate
        the "MinimalKeys" elements.
        '''

        #
        #        List of nodes in the system
        #
        if key == "nodes":
            self.Nodes = {}
            for node in value:
                # I don't think I need the IP address, etc. but this validates
                # the node name against /etc/hosts and/or DNS, so it's a
                # GoodThing(tm).
                self.Nodes[node] = gethostbyname_ex(node)
                if len(value) < 2:
                    raise ValueError("Must have at least two nodes in system")
            
        #
        #        Reset Mechanism
        #
        elif key == "reset":
            if not issubclass(value.__class__, ResetMechanism):
                raise ValueError("'reset' Value must be a subclass"
                " of ResetMechanism") 
        #
        #        List of Logging Mechanism(s)
        #
        elif key == "logger":
            if len(value) < 1:
                raise ValueError("Must have at least one logging mechanism")
            for logger in value:
                if not callable(logger):
                    raise ValueError("'logger' elements must be callable")
            self._logfunctions = value
        #
        #        Cluster Manager Class
        #
        elif key == "CMclass":
            if not issubclass(value, ClusterManager):
                raise ValueError("'CMclass' must be a subclass of"
                " ClusterManager")
        #
        #        Initial Random seed...
        #
        elif key == "RandSeed":
            if len(value) != 3:
                raise ValueError("'Randseed' must be a 3-element list/tuple")
            for elem in value:
                if not isinstance(elem, types.IntType):
                    raise ValueError("'Randseed' list must all be ints")
              
        self.data[key] = value

    def IsValidNode(self, node):
        'Return TRUE if the given node is valid'
        return self.Nodes.has_key(node)

    def __CheckNode(self, node):
        "Raise a ValueError if the given node isn't valid"

        if not self.IsValidNode(node):
            raise ValueError("Invalid node [%s] in CheckNode" % node)

    def RandomNode(self):
        '''Choose a random node from the cluster'''
        return self.RandomGen.choice(self["nodes"])

    def ResetNode(self, node):
        "Reset a node, (normally) using a hardware mechanism"
        self.__CheckNode(node)
        return self["reset"].reset(node)

def usage(arg):
    print "Illegal argument " + arg
    print "usage: " + sys.argv[0]  \
    +  " --directory config-directory" \
    +  " -D config-directory" \
    +  " --logfile system-logfile-name" \
    +  " -L system-logfile-name" \
    +  " --choose testcase" \
    +  " -v2"\
    +  " --stonith (1 | 0 | yes | no)" \
    +  " --standby (1 | 0 | yes | no)" \
    +  " --fencing (1 | 0 | yes | no)" \
    +  "  [number-of-iterations]"
    sys.exit(1)

    
#
#   A little test code...
#
if __name__ == '__main__': 

    from CTSaudits import AuditList
    from CTStests import TestList,RandomTests
    from CTS import Scenario, InitClusterManager, PingFest
    import CM_hb

    HAdir = "/etc/ha.d"
    LogFile = "/var/log/ha-log-local7"
    DoStonith = 1
    DoStandby = 1
    DoFencing = 0
    NumIter = 500
    SuppressMonitoring = None
    Version = 1
    CIBfilename = None
    CIBResource = 0
    ClobberCIB = 0
    LimitNodes = 0
    TestCase = None
    LogFacility = None
    
    #
    # The values of the rest of the parameters are now properly derived from
    # the configuration files.
    #
    # Stonith is configurable because it's slow, I have a few machines which
    # don't reboot very reliably, and it can mild damage to your machine if
    # you're using a real power switch.
    # 
    # Standby is configurable because the test is very heartbeat specific
    # and I haven't written the code to set it properly yet.  Patches are
    # being accepted...


    
    # Process arguments...

    skipthis=None
    args=sys.argv[1:]
    for i in range(0, len(args)):
       if skipthis:
           skipthis=None
           continue
       elif args[i] == "-D" or args[i] == "--directory":
           skipthis=1
           HAdir = args[i+1]
       elif args[i] == "-l" or args[i] == "--limit-nodes":
           skipthis=1
           LimitNodes = int(args[i+1])
       elif args[i] == "-r":
           CIBResource = 1
       elif args[i] == "-L" or args[i] == "--logfile":
           skipthis=1
           LogFile = args[i+1]
       elif args[i] == "-v2":
           Version=2
       elif args[i] == "--stonith":
           skipthis=1
           if args[i+1] == "1" or args[i+1] == "yes":
               DoStonith=1
           elif args[i+1] == "0" or args[i+1] == "no":
               DoStonith=0
           else:
               usage(args[i+1])
       elif args[i] == "--standby":
           skipthis=1
           if args[i+1] == "1" or args[i+1] == "yes":
               DoStandby=1
           elif args[i+1] == "0" or args[i+1] == "no":
               DoStandby=0
           else:
               usage(args[i+1])
       elif args[i] == "--fencing":
           skipthis=1
           if args[i+1] == "1" or args[i+1] == "yes":
               DoFencing=1
           elif args[i+1] == "0" or args[i+1] == "no":
               DoFencing=0
           else:
               usage(args[i+1])
       elif args[i] == "--suppressmonitoring":
           SuppressMonitoring = 1
       elif args[i] == "-2" or args[i] == "--crm":
           Version = 2
       elif args[i] == "-1" or args[i] == "--classic":
           Version = 1
       elif args[i] == "--clobber-cib" or args[i] == "-c":
           ClobberCIB = 1
       elif args[i] == "--cib-filename":
           skipthis=1
           CIBfilename = args[i+1]
       elif args[i] == "--choose":
           skipthis=1
           TestCase = args[i+1]
       elif args[i] == "--syslog-facility" or args[i] == "--facility":
           skipthis=1
           LogFacility = args[i+1]
       else:
           NumIter=int(args[i])
          
    #
    # This reading of HBconfig here is ugly, and I suppose ought to
    # be done by the Cluster manager.  This would probably mean moving the
    # list of cluster nodes into the ClusterManager class.  A good thought
    # for our Copious Spare Time in the future...
    #
    config = CM_hb.HBConfig(HAdir)
    node_list = config.Parameters["node"]
    if LogFacility == None:
        if config.Parameters.has_key("logfacility"): 
            LogFacility = config.Parameters["logfacility"][0]
        else:
            LogFacility = "local7"

    if LimitNodes > 0:
        if len(node_list) > LimitNodes:
            print("Limiting the number of nodes configured=%d (max=%d)"
                  %(len(node_list), LimitNodes))
            while len(node_list) > LimitNodes:
                node_list.pop(len(node_list)-1)

    Environment = CtsLab(node_list)
    Environment["HAdir"] = HAdir
    Environment["ClobberCIB"] = ClobberCIB
    Environment["CIBfilename"] = CIBfilename
    Environment["CIBResource"] = CIBResource 
    Environment["LogFileName"] = LogFile
    Environment["DoStonith"] = DoStonith
    Environment["SyslogFacility"] = LogFacility
    Environment["DoStandby"] = DoStandby
    Environment["DoFencing"] = DoFencing
    
    Environment["SuppressMonitoring"] = SuppressMonitoring
    if Version == 2:
        from CM_LinuxHAv2 import LinuxHAv2
        Environment['CMclass']=LinuxHAv2
    #Environment["RandSeed"] = (156, 104, 218)

    Environment.SupplyDefaults()

    # Your basic start up the world type of test scenario...

    #scenario = Scenario(
    #[        InitClusterManager(Environment)
    #,        PingFest(Environment)])
    scenario = Scenario(
    [        InitClusterManager(Environment)])

    # Create the Cluster Manager object

    cm = Environment['CMclass'](Environment)


    cm.log(">>>>>>>>>>>>>>>> BEGINNING " + repr(NumIter) + " TESTS ")
    cm.log("HA configuration directory: " + Environment["HAdir"])
    cm.log("System log files: " + Environment["LogFileName"])
    cm.log("Enable Stonith: " + ("%d" % Environment["DoStonith"]))
    cm.log("Enable Standby: " + ("%d" % Environment["DoStandby"]))
    if Environment.has_key("SuppressMonitoring") \
    and Environment["SuppressMonitoring"]:
        cm.log("Resource Monitoring is disabled")
    cm.log("Cluster nodes: " + repr(config.Parameters["node"]))

    Audits = AuditList(cm)
    Tests = []
    
    if TestCase != None:
        for test in TestList(cm):
            if test.name == TestCase:
                Tests.append(test)
        if Tests == []:
            usage("--choose: No applicable/valid tests chosen")        
    else:
        Tests = TestList(cm)    
    
    tests = RandomTests(scenario, cm, Tests, Audits)
    Environment.RandomTests = tests
    overall, detailed = tests.run(NumIter)
    tests.summarize()
