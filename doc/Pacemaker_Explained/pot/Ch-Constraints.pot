# 
# AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: 0\n"
"POT-Creation-Date: 2018-05-14 18:03-0500\n"
"PO-Revision-Date: 2018-05-14 18:03-0500\n"
"Last-Translator: Automatically generated\n"
"Language-Team: None\n"
"MIME-Version: 1.0\n"
"Content-Type: application/x-publican; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Tag: title
#, no-c-format
msgid "Resource Constraints"
msgstr ""

#. Tag: para
#, no-c-format
msgid "<indexterm> <primary>Resource</primary><secondary>Constraints</secondary> </indexterm> <indexterm> <primary>Constraints</primary> </indexterm>"
msgstr ""

#. Tag: title
#, no-c-format
msgid "Scores"
msgstr ""

#. Tag: para
#, no-c-format
msgid "Scores of all kinds are integral to how the cluster works. Practically everything from moving a resource to deciding which resource to stop in a degraded cluster is achieved by manipulating scores in some way."
msgstr ""

#. Tag: para
#, no-c-format
msgid "Scores are calculated per resource and node. Any node with a negative score for a resource can’t run that resource. The cluster places a resource on the node with the highest score for it."
msgstr ""

#. Tag: title
#, no-c-format
msgid "Infinity Math"
msgstr ""

#. Tag: para
#, no-c-format
msgid "Pacemaker implements <literal>INFINITY</literal> (or equivalently, <literal>+INFINITY</literal>) internally as a score of 1,000,000. Addition and subtraction with it follow these three basic rules:"
msgstr ""

#. Tag: para
#, no-c-format
msgid "Any value + <literal>INFINITY</literal> = <literal>INFINITY</literal>"
msgstr ""

#. Tag: para
#, no-c-format
msgid "Any value - <literal>INFINITY</literal> = <literal>-INFINITY</literal>"
msgstr ""

#. Tag: para
#, no-c-format
msgid "<literal>INFINITY</literal> - <literal>INFINITY</literal> = <literal>-INFINITY</literal>"
msgstr ""

#. Tag: para
#, no-c-format
msgid "What if you want to use a score higher than 1,000,000? Typically this possibility arises when someone wants to base the score on some external metric that might go above 1,000,000."
msgstr ""

#. Tag: para
#, no-c-format
msgid "The short answer is you can’t."
msgstr ""

#. Tag: para
#, no-c-format
msgid "The long answer is it is sometimes possible work around this limitation creatively. You may be able to set the score to some computed value based on the external metric rather than use the metric directly. For nodes, you can store the metric as a node attribute, and query the attribute when computing the score (possibly as part of a custom resource agent)."
msgstr ""

#. Tag: title
#, no-c-format
msgid "Deciding Which Nodes a Resource Can Run On"
msgstr ""

#. Tag: para
#, no-c-format
msgid "<indexterm> <primary>Location Constraints</primary> </indexterm> <indexterm> <primary>Resource</primary><secondary>Constraints</secondary><tertiary>Location</tertiary> </indexterm> <indexterm> <primary>Constraints</primary><secondary>Location</secondary> </indexterm> <indexterm> <primary>Location</primary> </indexterm> <emphasis>Location constraints</emphasis> tell the cluster which nodes a resource can run on."
msgstr ""

#. Tag: para
#, no-c-format
msgid "There are two alternative strategies. One way is to say that, by default, resources can run anywhere, and then the location constraints specify nodes that are not allowed (an <emphasis>opt-out</emphasis> cluster). The other way is to start with nothing able to run anywhere, and use location constraints to selectively enable allowed nodes (an <emphasis>opt-in</emphasis> cluster)."
msgstr ""

#. Tag: para
#, no-c-format
msgid "Whether you should choose opt-in or opt-out depends on your personal preference and the make-up of your cluster. If most of your resources can run on most of the nodes, then an opt-out arrangement is likely to result in a simpler configuration. On the other-hand, if most resources can only run on a small subset of nodes, an opt-in configuration might be simpler."
msgstr ""

#. Tag: title
#, no-c-format
msgid "Location Properties"
msgstr ""

#. Tag: title
#, no-c-format
msgid "Properties of a rsc_location Constraint"
msgstr ""

#. Tag: entry
#, no-c-format
msgid "Field"
msgstr ""

#. Tag: entry
#, no-c-format
msgid "Default"
msgstr ""

#. Tag: entry
#, no-c-format
msgid "Description"
msgstr ""

#. Tag: para
#, no-c-format
msgid "<literal>id</literal>"
msgstr ""

#. Tag: para
#, no-c-format
msgid "A unique name for the constraint <indexterm> <primary>id</primary><secondary>Location Constraints</secondary> </indexterm> <indexterm> <primary>Location Constraints</primary> </indexterm> <indexterm> <primary>Constraints</primary><secondary>Location</secondary><tertiary>id</tertiary> </indexterm> <indexterm> <primary>Location</primary><secondary>id</secondary> </indexterm> <indexterm> <primary>id</primary> </indexterm>"
msgstr ""

#. Tag: para
#, no-c-format
msgid "<literal>rsc</literal>"
msgstr ""

#. Tag: para
#, no-c-format
msgid "The name of the resource to which this constraint applies <indexterm> <primary>rsc</primary><secondary>Location Constraints</secondary> </indexterm> <indexterm> <primary>Location Constraints</primary> </indexterm> <indexterm> <primary>Constraints</primary><secondary>Location</secondary><tertiary>rsc</tertiary> </indexterm> <indexterm> <primary>Location</primary><secondary>rsc</secondary> </indexterm> <indexterm> <primary>rsc</primary> </indexterm>"
msgstr ""

#. Tag: para
#, no-c-format
msgid "<literal>rsc-pattern</literal>"
msgstr ""

#. Tag: para
#, no-c-format
msgid "An extended regular expression (as defined in <ulink url=\"http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_04\">POSIX</ulink>) matching the names of resources to which this constraint applies, if <literal>rsc</literal> is not specified; if the regular expression contains submatches and the constraint is governed by a rule (see <xref linkend=\"ch-rules\" />), the submatches can be referenced as <literal>%0</literal> through <literal>%9</literal> in the rule’s <literal>score-attribute</literal> or a rule expression’s <literal>attribute</literal> <indexterm> <primary>rsc-pattern</primary><secondary>Location Constraints</secondary> </indexterm> <indexterm> <primary>Location Constraints</primary> </indexterm> <indexterm> <primary>Constraints</primary><secondary>Location</secondary><tertiary>rsc-pattern</tertiary> </indexterm> <indexterm> <primary>Location</primary><secondary>rsc-pattern</secondary> </indexterm> <indexterm> <primary>rsc-pattern</primary> </indexterm>"
msgstr ""

#. Tag: para
#, no-c-format
msgid "<literal>node</literal>"
msgstr ""

#. Tag: para
#, no-c-format
msgid "A node’s name <indexterm> <primary>node</primary><secondary>Location Constraints</secondary> </indexterm> <indexterm> <primary>Location Constraints</primary> </indexterm> <indexterm> <primary>Constraints</primary><secondary>Location</secondary><tertiary>node</tertiary> </indexterm> <indexterm> <primary>Location</primary><secondary>node</secondary> </indexterm> <indexterm> <primary>node</primary> </indexterm>"
msgstr ""

#. Tag: para
#, no-c-format
msgid "<literal>score</literal>"
msgstr ""

#. Tag: para
#, no-c-format
msgid "Positive values indicate a preference for running the affected resource(s) on this node — the higher the value, the stronger the preference. Negative values indicate the resource(s) should avoid this node (a value of <literal>-INFINITY</literal> changes \"should\" to \"must\"). <indexterm> <primary>score</primary><secondary>Location Constraints</secondary> </indexterm> <indexterm> <primary>Location Constraints</primary> </indexterm> <indexterm> <primary>Constraints</primary><secondary>Location</secondary><tertiary>score</tertiary> </indexterm> <indexterm> <primary>Location</primary><secondary>score</secondary> </indexterm> <indexterm> <primary>score</primary> </indexterm>"
msgstr ""

#. Tag: para
#, no-c-format
msgid "<literal>resource-discovery</literal>"
msgstr ""

#. Tag: para
#, no-c-format
msgid "always"
msgstr ""

#. Tag: para
#, no-c-format
msgid "Whether Pacemaker should perform resource discovery (that is, check whether the resource is already running) for this resource on this node. This should normally be left as the default, so that rogue instances of a service can be stopped when they are running where they are not supposed to be. However, there are two situations where disabling resource discovery is a good idea: when a service is not installed on a node, discovery might return an error (properly written OCF agents will not, so this is usually only seen with other agent types); and when Pacemaker Remote is used to scale a cluster to hundreds of nodes, limiting resource discovery to allowed nodes can significantly boost performance."
msgstr ""

#. Tag: para
#, no-c-format
msgid "<literal>always:</literal> Always perform resource discovery for the specified resource on this node."
msgstr ""

#. Tag: para
#, no-c-format
msgid "<literal>never:</literal> Never perform resource discovery for the specified resource on this node. This option should generally be used with a -INFINITY score, although that is not strictly required."
msgstr ""

#. Tag: para
#, no-c-format
msgid "<literal>exclusive:</literal> Perform resource discovery for the specified resource only on this node (and other nodes similarly marked as <literal>exclusive</literal>). Multiple location constraints using <literal>exclusive</literal> discovery for the same resource across different nodes creates a subset of nodes resource-discovery is exclusive to. If a resource is marked for <literal>exclusive</literal> discovery on one or more nodes, that resource is only allowed to be placed within that subset of nodes."
msgstr ""

#. Tag: para
#, no-c-format
msgid "<indexterm> <primary>Resource Discovery</primary><secondary>Location Constraints</secondary> </indexterm> <indexterm> <primary>Location Constraints</primary> </indexterm> <indexterm> <primary>Constraints</primary><secondary>Location</secondary><tertiary>Resource Discovery</tertiary> </indexterm> <indexterm> <primary>Location</primary><secondary>Resource Discovery</secondary> </indexterm> <indexterm> <primary>Resource Discovery</primary> </indexterm>"
msgstr ""

#. Tag: para
#, no-c-format
msgid "Setting resource-discovery to <literal>never</literal> or <literal>exclusive</literal> removes Pacemaker’s ability to detect and stop unwanted instances of a service running where it’s not supposed to be. It is up to the system administrator (you!) to make sure that the service can <emphasis>never</emphasis> be active on nodes without resource-discovery (such as by leaving the relevant software uninstalled)."
msgstr ""

#. Tag: title
#, no-c-format
msgid "Asymmetrical \"Opt-In\" Clusters"
msgstr ""

#. Tag: para
#, no-c-format
msgid "<indexterm> <primary>Asymmetrical Opt-In Clusters</primary> </indexterm> <indexterm> <primary>Cluster Type</primary><secondary>Asymmetrical Opt-In</secondary> </indexterm> <indexterm> <primary>Asymmetrical Opt-In</primary> </indexterm>"
msgstr ""

#. Tag: para
#, no-c-format
msgid "To create an opt-in cluster, start by preventing resources from running anywhere by default:"
msgstr ""

#. Tag: screen
#, no-c-format
msgid "# crm_attribute --name symmetric-cluster --update false"
msgstr ""

#. Tag: para
#, no-c-format
msgid "Then start enabling nodes. The following fragment says that the web server prefers <emphasis role=\"strong\">sles-1</emphasis>, the database prefers <emphasis role=\"strong\">sles-2</emphasis> and both can fail over to <emphasis role=\"strong\">sles-3</emphasis> if their most preferred node fails."
msgstr ""

#. Tag: title
#, no-c-format
msgid "Opt-in location constraints for two resources"
msgstr ""

#. Tag: programlisting
#, no-c-format
msgid "&lt;constraints&gt;\n"
"    &lt;rsc_location id=\"loc-1\" rsc=\"Webserver\" node=\"sles-1\" score=\"200\"/&gt;\n"
"    &lt;rsc_location id=\"loc-2\" rsc=\"Webserver\" node=\"sles-3\" score=\"0\"/&gt;\n"
"    &lt;rsc_location id=\"loc-3\" rsc=\"Database\" node=\"sles-2\" score=\"200\"/&gt;\n"
"    &lt;rsc_location id=\"loc-4\" rsc=\"Database\" node=\"sles-3\" score=\"0\"/&gt;\n"
"&lt;/constraints&gt;"
msgstr ""

#. Tag: title
#, no-c-format
msgid "Symmetrical \"Opt-Out\" Clusters"
msgstr ""

#. Tag: para
#, no-c-format
msgid "<indexterm> <primary>Symmetrical Opt-Out Clusters</primary> </indexterm> <indexterm> <primary>Cluster Type</primary><secondary>Symmetrical Opt-Out</secondary> </indexterm> <indexterm> <primary>Symmetrical Opt-Out</primary> </indexterm>"
msgstr ""

#. Tag: para
#, no-c-format
msgid "To create an opt-out cluster, start by allowing resources to run anywhere by default:"
msgstr ""

#. Tag: screen
#, no-c-format
msgid "# crm_attribute --name symmetric-cluster --update true"
msgstr ""

#. Tag: para
#, no-c-format
msgid "Then start disabling nodes. The following fragment is the equivalent of the above opt-in configuration."
msgstr ""

#. Tag: title
#, no-c-format
msgid "Opt-out location constraints for two resources"
msgstr ""

#. Tag: programlisting
#, no-c-format
msgid "&lt;constraints&gt;\n"
"    &lt;rsc_location id=\"loc-1\" rsc=\"Webserver\" node=\"sles-1\" score=\"200\"/&gt;\n"
"    &lt;rsc_location id=\"loc-2-dont-run\" rsc=\"Webserver\" node=\"sles-2\" score=\"-INFINITY\"/&gt;\n"
"    &lt;rsc_location id=\"loc-3-dont-run\" rsc=\"Database\" node=\"sles-1\" score=\"-INFINITY\"/&gt;\n"
"    &lt;rsc_location id=\"loc-4\" rsc=\"Database\" node=\"sles-2\" score=\"200\"/&gt;\n"
"&lt;/constraints&gt;"
msgstr ""

#. Tag: title
#, no-c-format
msgid "What if Two Nodes Have the Same Score"
msgstr ""

#. Tag: para
#, no-c-format
msgid "If two nodes have the same score, then the cluster will choose one. This choice may seem random and may not be what was intended, however the cluster was not given enough information to know any better."
msgstr ""

#. Tag: title
#, no-c-format
msgid "Constraints where a resource prefers two nodes equally"
msgstr ""

#. Tag: programlisting
#, no-c-format
msgid "&lt;constraints&gt;\n"
"    &lt;rsc_location id=\"loc-1\" rsc=\"Webserver\" node=\"sles-1\" score=\"INFINITY\"/&gt;\n"
"    &lt;rsc_location id=\"loc-2\" rsc=\"Webserver\" node=\"sles-2\" score=\"INFINITY\"/&gt;\n"
"    &lt;rsc_location id=\"loc-3\" rsc=\"Database\" node=\"sles-1\" score=\"500\"/&gt;\n"
"    &lt;rsc_location id=\"loc-4\" rsc=\"Database\" node=\"sles-2\" score=\"300\"/&gt;\n"
"    &lt;rsc_location id=\"loc-5\" rsc=\"Database\" node=\"sles-2\" score=\"200\"/&gt;\n"
"&lt;/constraints&gt;"
msgstr ""

#. Tag: para
#, no-c-format
msgid "In the example above, assuming no other constraints and an inactive cluster, <literal>Webserver</literal> would probably be placed on <literal>sles-1</literal> and <literal>Database</literal> on <literal>sles-2</literal>. It would likely have placed <literal>Webserver</literal> based on the node’s uname and <literal>Database</literal> based on the desire to spread the resource load evenly across the cluster. However other factors can also be involved in more complex configurations."
msgstr ""

#. Tag: title
#, no-c-format
msgid "Specifying the Order in which Resources Should Start/Stop"
msgstr ""

#. Tag: para
#, no-c-format
msgid "<indexterm> <primary>Resource</primary><secondary>Constraints</secondary><tertiary>Ordering</tertiary> </indexterm> <indexterm> <primary>Constraints</primary><secondary>Ordering</secondary> </indexterm> <indexterm> <primary>Ordering</primary> </indexterm> <indexterm> <primary>Resource</primary><secondary>Start Order</secondary> </indexterm> <indexterm> <primary>Start Order</primary> </indexterm> <indexterm> <primary>Ordering Constraints</primary> </indexterm>"
msgstr ""

#. Tag: para
#, no-c-format
msgid "<emphasis>Ordering constraints</emphasis> tell the cluster the order in which resources should start."
msgstr ""

#. Tag: para
#, no-c-format
msgid "Ordering constraints affect <emphasis>only</emphasis> the ordering of resources; they do <emphasis>not</emphasis> require that the resources be placed on the same node. If you want resources to be started on the same node <emphasis>and</emphasis> in a specific order, you need both an ordering constraint <emphasis>and</emphasis> a colocation constraint (see <xref linkend=\"s-resource-colocation\" />), or alternatively, a group (see <xref linkend=\"group-resources\" />)."
msgstr ""

#. Tag: title
#, no-c-format
msgid "Ordering Properties"
msgstr ""

#. Tag: title
#, no-c-format
msgid "Properties of a rsc_order Constraint"
msgstr ""

#. Tag: para
#, no-c-format
msgid "A unique name for the constraint <indexterm> <primary>id</primary><secondary>Ordering Constraints</secondary> </indexterm> <indexterm> <primary>Ordering Constraints</primary> </indexterm> <indexterm> <primary>Constraints</primary><secondary>Ordering</secondary><tertiary>id</tertiary> </indexterm> <indexterm> <primary>Ordering</primary><secondary>id</secondary> </indexterm> <indexterm> <primary>id</primary> </indexterm>"
msgstr ""

#. Tag: para
#, no-c-format
msgid "<literal>first</literal>"
msgstr ""

#. Tag: para
#, no-c-format
msgid "Name of the resource that the <literal>then</literal> resource depends on <indexterm> <primary>first</primary><secondary>Ordering Constraints</secondary> </indexterm> <indexterm> <primary>Ordering Constraints</primary> </indexterm> <indexterm> <primary>Constraints</primary><secondary>Ordering</secondary><tertiary>first</tertiary> </indexterm> <indexterm> <primary>Ordering</primary><secondary>first</secondary> </indexterm> <indexterm> <primary>first</primary> </indexterm>"
msgstr ""

#. Tag: para
#, no-c-format
msgid "<literal>then</literal>"
msgstr ""

#. Tag: para
#, no-c-format
msgid "Name of the dependent resource <indexterm> <primary>then</primary><secondary>Ordering Constraints</secondary> </indexterm> <indexterm> <primary>Ordering Constraints</primary> </indexterm> <indexterm> <primary>Constraints</primary><secondary>Ordering</secondary><tertiary>then</tertiary> </indexterm> <indexterm> <primary>Ordering</primary><secondary>then</secondary> </indexterm> <indexterm> <primary>then</primary> </indexterm>"
msgstr ""

#. Tag: para
#, no-c-format
msgid "<literal>first-action</literal>"
msgstr ""

#. Tag: para
#, no-c-format
msgid "start"
msgstr ""

#. Tag: para
#, no-c-format
msgid "The action that the <literal>first</literal> resource must complete before <literal>then-action</literal> can be initiated for the <literal>then</literal> resource. Allowed values: <literal>start</literal>, <literal>stop</literal>, <literal>promote</literal>, <literal>demote</literal>. <indexterm> <primary>first-action</primary><secondary>Ordering Constraints</secondary> </indexterm> <indexterm> <primary>Ordering Constraints</primary> </indexterm> <indexterm> <primary>Constraints</primary><secondary>Ordering</secondary><tertiary>first-action</tertiary> </indexterm> <indexterm> <primary>Ordering</primary><secondary>first-action</secondary> </indexterm> <indexterm> <primary>first-action</primary> </indexterm>"
msgstr ""

#. Tag: para
#, no-c-format
msgid "<literal>then-action</literal>"
msgstr ""

#. Tag: para
#, no-c-format
msgid "value of <literal>first-action</literal>"
msgstr ""

#. Tag: para
#, no-c-format
msgid "The action that the <literal>then</literal> resource can execute only after the <literal>first-action</literal> on the <literal>first</literal> resource has completed. Allowed values: <literal>start</literal>, <literal>stop</literal>, <literal>promote</literal>, <literal>demote</literal>. <indexterm> <primary>then-action</primary><secondary>Ordering Constraints</secondary> </indexterm> <indexterm> <primary>Ordering Constraints</primary> </indexterm> <indexterm> <primary>Constraints</primary><secondary>Ordering</secondary><tertiary>then-action</tertiary> </indexterm> <indexterm> <primary>Ordering</primary><secondary>then-action</secondary> </indexterm> <indexterm> <primary>then-action</primary> </indexterm>"
msgstr ""

#. Tag: para
#, no-c-format
msgid "<literal>kind</literal>"
msgstr ""

#. Tag: para
#, no-c-format
msgid "How to enforce the constraint. Allowed values:"
msgstr ""

#. Tag: para
#, no-c-format
msgid "<literal>Optional:</literal> Just a suggestion. Only applies if both resources are executing the specified actions. Any change in state by the <literal>first</literal> resource will have no effect on the <literal>then</literal> resource."
msgstr ""

#. Tag: para
#, no-c-format
msgid "<literal>Mandatory:</literal> Always. If <literal>first</literal> does not perform <literal>first-action</literal>, <literal>then</literal> will not be allowed to performed <literal>then-action</literal>. If <literal>first</literal> is restarted, <literal>then</literal> (if running) will be stopped beforehand and started afterward."
msgstr ""

#. Tag: para
#, no-c-format
msgid "<literal>Serialize:</literal> Ensure that no two stop/start actions occur concurrently for the resources. <literal>First</literal> and <literal>then</literal> can start in either order, but one must complete starting before the other can be started. A typical use case is when resource start-up puts a high load on the host."
msgstr ""

#. Tag: para
#, no-c-format
msgid "<indexterm> <primary>kind</primary><secondary>Ordering Constraints</secondary> </indexterm> <indexterm> <primary>Ordering Constraints</primary> </indexterm> <indexterm> <primary>Constraints</primary><secondary>Ordering</secondary><tertiary>kind</tertiary> </indexterm> <indexterm> <primary>Ordering</primary><secondary>kind</secondary> </indexterm> <indexterm> <primary>kind</primary> </indexterm>"
msgstr ""

#. Tag: para
#, no-c-format
msgid "<literal>symmetrical</literal>"
msgstr ""

#. Tag: para
#, no-c-format
msgid "TRUE for <literal>Mandatory</literal> and <literal>Optional</literal> kinds. FALSE for <literal>Serialize</literal> kind."
msgstr ""

#. Tag: para
#, no-c-format
msgid "If true, the reverse of the constraint applies for the opposite action (for example, if B starts after A starts, then B stops before A stops). <literal>Serialize</literal> orders cannot be symmetrical. <indexterm> <primary>symmetrical</primary><secondary>Ordering Constraints</secondary> </indexterm> <indexterm> <primary>Ordering Constraints</primary> </indexterm> <indexterm> <primary>Ordering Constraints</primary><secondary>symmetrical</secondary> </indexterm> <indexterm> <primary>symmetrical</primary> </indexterm>"
msgstr ""

#. Tag: para
#, no-c-format
msgid "<literal>Promote</literal> and <literal>demote</literal> apply to the master role of <link linkend=\"s-resource-promotable\">promotable</link> resources."
msgstr ""

#. Tag: title
#, no-c-format
msgid "Optional and mandatory ordering"
msgstr ""

#. Tag: para
#, no-c-format
msgid "Here is an example of ordering constraints where <literal>Database</literal> <emphasis>must</emphasis> start before <literal>Webserver</literal>, and <literal>IP</literal> <emphasis>should</emphasis> start before <literal>Webserver</literal> if they both need to be started:"
msgstr ""

#. Tag: title
#, no-c-format
msgid "Optional and mandatory ordering constraints"
msgstr ""

#. Tag: programlisting
#, no-c-format
msgid "&lt;constraints&gt;\n"
"&lt;rsc_order id=\"order-1\" first=\"IP\" then=\"Webserver\" kind=\"Optional\"/&gt;\n"
"&lt;rsc_order id=\"order-2\" first=\"Database\" then=\"Webserver\" kind=\"Mandatory\" /&gt;\n"
"&lt;/constraints&gt;"
msgstr ""

#. Tag: para
#, no-c-format
msgid "Because the above example lets <literal>symmetrical</literal> default to TRUE, <literal>Webserver</literal> must be stopped before <literal>Database</literal> can be stopped, and <literal>Webserver</literal> should be stopped before <literal>IP</literal> if they both need to be stopped."
msgstr ""

#. Tag: title
#, no-c-format
msgid "Placing Resources Relative to other Resources"
msgstr ""

#. Tag: para
#, no-c-format
msgid "<indexterm> <primary>Resource</primary><secondary>Constraints</secondary><tertiary>Colocation</tertiary> </indexterm> <indexterm> <primary>Constraints</primary><secondary>Colocation</secondary> </indexterm> <indexterm> <primary>Colocation</primary> </indexterm> <indexterm> <primary>Resource</primary><secondary>Location Relative to other Resources</secondary> </indexterm> <indexterm> <primary>Location Relative to other Resources</primary> </indexterm> <emphasis>Colocation constraints</emphasis> tell the cluster that the location of one resource depends on the location of another one."
msgstr ""

#. Tag: para
#, no-c-format
msgid "Colocation has an important side-effect: it affects the order in which resources are assigned to a node. Think about it: You can’t place A relative to B unless you know where B is. <footnote><para> While the human brain is sophisticated enough to read the constraint in any order and choose the correct one depending on the situation, the cluster is not quite so smart. Yet. </para></footnote>"
msgstr ""

#. Tag: para
#, no-c-format
msgid "So when you are creating colocation constraints, it is important to consider whether you should colocate A with B, or B with A."
msgstr ""

#. Tag: para
#, no-c-format
msgid "Another thing to keep in mind is that, assuming A is colocated with B, the cluster will take into account A’s preferences when deciding which node to choose for B."
msgstr ""

#. Tag: para
#, no-c-format
msgid "For a detailed look at exactly how this occurs, see <ulink url=\"http://clusterlabs.org/doc/Colocation_Explained.pdf\">Colocation Explained</ulink>."
msgstr ""

#. Tag: para
#, no-c-format
msgid "Colocation constraints affect <emphasis>only</emphasis> the placement of resources; they do <emphasis>not</emphasis> require that the resources be started in a particular order. If you want resources to be started on the same node <emphasis>and</emphasis> in a specific order, you need both an ordering constraint (see <xref linkend=\"s-resource-ordering\" />) <emphasis>and</emphasis> a colocation constraint, or alternatively, a group (see <xref linkend=\"group-resources\" />)."
msgstr ""

#. Tag: title
#, no-c-format
msgid "Colocation Properties"
msgstr ""

#. Tag: title
#, no-c-format
msgid "Properties of a rsc_colocation Constraint"
msgstr ""

#. Tag: para
#, no-c-format
msgid "A unique name for the constraint (required). <indexterm> <primary>id</primary><secondary>Colocation Constraints</secondary> </indexterm> <indexterm> <primary>Colocation Constraints</primary> </indexterm> <indexterm> <primary>Constraints</primary><secondary>Colocation</secondary><tertiary>id</tertiary> </indexterm> <indexterm> <primary>Colocation</primary><secondary>id</secondary> </indexterm> <indexterm> <primary>id</primary> </indexterm>"
msgstr ""

#. Tag: para
#, no-c-format
msgid "The name of a resource that should be located relative to <literal>with-rsc</literal> (required). <indexterm> <primary>rsc</primary><secondary>Colocation Constraints</secondary> </indexterm> <indexterm> <primary>Colocation Constraints</primary> </indexterm> <indexterm> <primary>Constraints</primary><secondary>Colocation</secondary><tertiary>rsc</tertiary> </indexterm> <indexterm> <primary>Colocation</primary><secondary>rsc</secondary> </indexterm> <indexterm> <primary>rsc</primary> </indexterm>"
msgstr ""

#. Tag: para
#, no-c-format
msgid "<literal>with-rsc</literal>"
msgstr ""

#. Tag: para
#, no-c-format
msgid "The name of the resource used as the colocation target. The cluster will decide where to put this resource first and then decide where to put <literal>rsc</literal> (required). <indexterm> <primary>with-rsc</primary><secondary>Colocation Constraints</secondary> </indexterm> <indexterm> <primary>Colocation Constraints</primary> </indexterm> <indexterm> <primary>Constraints</primary><secondary>Colocation</secondary><tertiary>with-rsc</tertiary> </indexterm> <indexterm> <primary>Colocation</primary><secondary>with-rsc</secondary> </indexterm> <indexterm> <primary>with-rsc</primary> </indexterm>"
msgstr ""

#. Tag: para
#, no-c-format
msgid "<literal>node-attribute</literal>"
msgstr ""

#. Tag: para
#, no-c-format
msgid "#uname"
msgstr ""

#. Tag: para
#, no-c-format
msgid "The node attribute that must be the same on the node running <literal>rsc</literal> and the node running <literal>with-rsc</literal> for the constraint to be satisfied. (For details, see <xref linkend=\"s-coloc-attribute\" />.) <indexterm> <primary>node-attribute</primary><secondary>Colocation Constraints</secondary> </indexterm> <indexterm> <primary>Colocation Constraints</primary> </indexterm> <indexterm> <primary>Constraints</primary><secondary>Colocation</secondary><tertiary>node-attribute</tertiary> </indexterm> <indexterm> <primary>Colocation</primary><secondary>node-attribute</secondary> </indexterm> <indexterm> <primary>node-attribute</primary> </indexterm>"
msgstr ""

#. Tag: para
#, no-c-format
msgid "Positive values indicate the resources should run on the same node. Negative values indicate the resources should run on different nodes. Values of +/- <literal>INFINITY</literal> change \"should\" to \"must\". <indexterm> <primary>score</primary><secondary>Colocation Constraints</secondary> </indexterm> <indexterm> <primary>Colocation Constraints</primary> </indexterm> <indexterm> <primary>Constraints</primary><secondary>Colocation</secondary><tertiary>score</tertiary> </indexterm> <indexterm> <primary>Colocation</primary><secondary>score</secondary> </indexterm> <indexterm> <primary>score</primary> </indexterm>"
msgstr ""

#. Tag: title
#, no-c-format
msgid "Mandatory Placement"
msgstr ""

#. Tag: para
#, no-c-format
msgid "Mandatory placement occurs when the constraint’s score is <literal>+INFINITY</literal> or <literal>-INFINITY</literal>. In such cases, if the constraint can’t be satisfied, then the <literal>rsc</literal> resource is not permitted to run. For <literal>score=INFINITY</literal>, this includes cases where the <literal>with-rsc</literal> resource is not active."
msgstr ""

#. Tag: para
#, no-c-format
msgid "If you need resource <literal>A</literal> to always run on the same machine as resource <literal>B</literal>, you would add the following constraint:"
msgstr ""

#. Tag: title
#, no-c-format
msgid "Mandatory colocation constraint for two resources"
msgstr ""

#. Tag: programlisting
#, no-c-format
msgid "&lt;rsc_colocation id=\"colocate\" rsc=\"A\" with-rsc=\"B\" score=\"INFINITY\"/&gt;"
msgstr ""

#. Tag: para
#, no-c-format
msgid "Remember, because <literal>INFINITY</literal> was used, if <literal>B</literal> can’t run on any of the cluster nodes (for whatever reason) then <literal>A</literal> will not be allowed to run. Whether <literal>A</literal> is running or not has no effect on <literal>B</literal>."
msgstr ""

#. Tag: para
#, no-c-format
msgid "Alternatively, you may want the opposite — that <literal>A</literal> <emphasis>cannot</emphasis> run on the same machine as <literal>B</literal>. In this case, use <literal>score=\"-INFINITY\"</literal>."
msgstr ""

#. Tag: title
#, no-c-format
msgid "Mandatory anti-colocation constraint for two resources"
msgstr ""

#. Tag: programlisting
#, no-c-format
msgid "&lt;rsc_colocation id=\"anti-colocate\" rsc=\"A\" with-rsc=\"B\" score=\"-INFINITY\"/&gt;"
msgstr ""

#. Tag: para
#, no-c-format
msgid "Again, by specifying <literal>-INFINITY</literal>, the constraint is binding. So if the only place left to run is where <literal>B</literal> already is, then <literal>A</literal> may not run anywhere."
msgstr ""

#. Tag: para
#, no-c-format
msgid "As with <literal>INFINITY</literal>, <literal>B</literal> can run even if <literal>A</literal> is stopped. However, in this case <literal>A</literal> also can run if <literal>B</literal> is stopped, because it still meets the constraint of <literal>A</literal> and <literal>B</literal> not running on the same node."
msgstr ""

#. Tag: title
#, no-c-format
msgid "Advisory Placement"
msgstr ""

#. Tag: para
#, no-c-format
msgid "If mandatory placement is about \"must\" and \"must not\", then advisory placement is the \"I’d prefer if\" alternative. For constraints with scores greater than <literal>-INFINITY</literal> and less than <literal>INFINITY</literal>, the cluster will try to accommodate your wishes but may ignore them if the alternative is to stop some of the cluster resources."
msgstr ""

#. Tag: para
#, no-c-format
msgid "As in life, where if enough people prefer something it effectively becomes mandatory, advisory colocation constraints can combine with other elements of the configuration to behave as if they were mandatory."
msgstr ""

#. Tag: title
#, no-c-format
msgid "Advisory colocation constraint for two resources"
msgstr ""

#. Tag: programlisting
#, no-c-format
msgid "&lt;rsc_colocation id=\"colocate-maybe\" rsc=\"A\" with-rsc=\"B\" score=\"500\"/&gt;"
msgstr ""

#. Tag: title
#, no-c-format
msgid "Colocation by Node Attribute"
msgstr ""

#. Tag: para
#, no-c-format
msgid "The <literal>node-attribute</literal> property of a colocation constraints allows you to express the requirement, \"these resources must be on similar nodes\"."
msgstr ""

#. Tag: para
#, no-c-format
msgid "As an example, imagine that you have two Storage Area Networks (SANs) that are not controlled by the cluster, and each node is connected to one or the other. You may have two resources <literal>r1</literal> and <literal>r2</literal> such that <literal>r2</literal> needs to use the same SAN as <literal>r1</literal>, but doesn’t necessarily have to be on the same exact node. In such a case, you could define a <link linkend=\"s-node-attributes\">node attribute</link> named <literal>san</literal>, with the value <literal>san1</literal> or <literal>san2</literal> on each node as appropriate. Then, you could colocate <literal>r2</literal> with <literal>r1</literal> using <literal>node-attribute</literal> set to <literal>san</literal>."
msgstr ""

#. Tag: title
#, no-c-format
msgid "Resource Sets"
msgstr ""

#. Tag: para
#, no-c-format
msgid "<emphasis>Resource sets</emphasis> allow multiple resources to be affected by a single constraint."
msgstr ""

#. Tag: title
#, no-c-format
msgid "A set of 3 resources"
msgstr ""

#. Tag: programlisting
#, no-c-format
msgid "&lt;resource_set id=\"resource-set-example\"&gt;\n"
"   &lt;resource_ref id=\"A\"/&gt;\n"
"   &lt;resource_ref id=\"B\"/&gt;\n"
"   &lt;resource_ref id=\"C\"/&gt;\n"
"&lt;/resource_set&gt;"
msgstr ""

#. Tag: para
#, no-c-format
msgid "Resource sets are valid inside <literal>rsc_location</literal>, <literal>rsc_order</literal> (see <xref linkend=\"s-resource-sets-ordering\" />), <literal>rsc_colocation</literal> (see <xref linkend=\"s-resource-sets-colocation\" />), and <literal>rsc_ticket</literal> (see <xref linkend=\"s-ticket-constraints\" />) constraints."
msgstr ""

#. Tag: para
#, no-c-format
msgid "A resource set has a number of properties that can be set, though not all have an effect in all contexts."
msgstr ""

#. Tag: title
#, no-c-format
msgid "Properties of a resource_set"
msgstr ""

#. Tag: para
#, no-c-format
msgid "A unique name for the set <indexterm> <primary>id</primary><secondary>Resource Sets</secondary> </indexterm> <indexterm> <primary>Resource Sets</primary> </indexterm> <indexterm> <primary>Constraints</primary><secondary>Resource Sets</secondary><tertiary>id</tertiary> </indexterm> <indexterm> <primary>Resource Sets</primary><secondary>id</secondary> </indexterm> <indexterm> <primary>id</primary> </indexterm>"
msgstr ""

#. Tag: para
#, no-c-format
msgid "<literal>sequential</literal>"
msgstr ""

#. Tag: para
#, no-c-format
msgid "true"
msgstr ""

#. Tag: para
#, no-c-format
msgid "Whether the members of the set must be acted on in order. Meaningful within <literal>rsc_order</literal> and <literal>rsc_colocation</literal>. <indexterm> <primary>sequential</primary><secondary>Resource Sets</secondary> </indexterm> <indexterm> <primary>Resource Sets</primary> </indexterm> <indexterm> <primary>Constraints</primary><secondary>Resource Sets</secondary><tertiary>sequential</tertiary> </indexterm> <indexterm> <primary>Resource Sets</primary><secondary>sequential</secondary> </indexterm> <indexterm> <primary>sequential</primary> </indexterm>"
msgstr ""

#. Tag: para
#, no-c-format
msgid "<literal>require-all</literal>"
msgstr ""

#. Tag: para
#, no-c-format
msgid "Whether all members of the set must be active before continuing. With the current implementation, the cluster may continue even if only one member of the set is started, but if more than one member of the set is starting at the same time, the cluster will still wait until all of those have started before continuing (this may change in future versions). Meaningful within <literal>rsc_order</literal>. <indexterm> <primary>require-all</primary><secondary>Resource Sets</secondary> </indexterm> <indexterm> <primary>Resource Sets</primary> </indexterm> <indexterm> <primary>Constraints</primary><secondary>Resource Sets</secondary><tertiary>require-all</tertiary> </indexterm> <indexterm> <primary>Resource Sets</primary><secondary>require-all</secondary> </indexterm> <indexterm> <primary>require-all</primary> </indexterm>"
msgstr ""

#. Tag: para
#, no-c-format
msgid "<literal>role</literal>"
msgstr ""

#. Tag: para
#, no-c-format
msgid "Limit the effect of the constraint to the specified role. Meaningful within <literal>rsc_location</literal>, <literal>rsc_colocation</literal> and <literal>rsc_ticket</literal>. <indexterm> <primary>role</primary><secondary>Resource Sets</secondary> </indexterm> <indexterm> <primary>Resource Sets</primary> </indexterm> <indexterm> <primary>Constraints</primary><secondary>Resource Sets</secondary><tertiary>role</tertiary> </indexterm> <indexterm> <primary>Resource Sets</primary><secondary>role</secondary> </indexterm> <indexterm> <primary>role</primary> </indexterm>"
msgstr ""

#. Tag: para
#, no-c-format
msgid "<literal>action</literal>"
msgstr ""

#. Tag: para
#, no-c-format
msgid "Limit the effect of the constraint to the specified action. Meaningful within <literal>rsc_order</literal>. <indexterm> <primary>action</primary><secondary>Resource Sets</secondary> </indexterm> <indexterm> <primary>Resource Sets</primary> </indexterm> <indexterm> <primary>Constraints</primary><secondary>Resource Sets</secondary><tertiary>action</tertiary> </indexterm> <indexterm> <primary>Resource Sets</primary><secondary>action</secondary> </indexterm> <indexterm> <primary>action</primary> </indexterm>"
msgstr ""

#. Tag: para
#, no-c-format
msgid "<emphasis>Advanced use only.</emphasis> Use a specific score for this set within the constraint. <indexterm> <primary>score</primary><secondary>Resource Sets</secondary> </indexterm> <indexterm> <primary>Resource Sets</primary> </indexterm> <indexterm> <primary>Constraints</primary><secondary>Resource Sets</secondary><tertiary>score</tertiary> </indexterm> <indexterm> <primary>Resource Sets</primary><secondary>score</secondary> </indexterm> <indexterm> <primary>score</primary> </indexterm>"
msgstr ""

#. Tag: title
#, no-c-format
msgid "Ordering Sets of Resources"
msgstr ""

#. Tag: para
#, no-c-format
msgid "A common situation is for an administrator to create a chain of ordered resources, such as:"
msgstr ""

#. Tag: title
#, no-c-format
msgid "A chain of ordered resources"
msgstr ""

#. Tag: programlisting
#, no-c-format
msgid "&lt;constraints&gt;\n"
"    &lt;rsc_order id=\"order-1\" first=\"A\" then=\"B\" /&gt;\n"
"    &lt;rsc_order id=\"order-2\" first=\"B\" then=\"C\" /&gt;\n"
"    &lt;rsc_order id=\"order-3\" first=\"C\" then=\"D\" /&gt;\n"
"&lt;/constraints&gt;"
msgstr ""

#. Tag: title
#, no-c-format
msgid "Visual representation of the four resources' start order for the above constraints"
msgstr ""

#. Tag: title
#, no-c-format
msgid "Ordered Set"
msgstr ""

#. Tag: para
#, no-c-format
msgid "To simplify this situation, resource sets (see <xref linkend=\"s-resource-sets\" />) can be used within ordering constraints:"
msgstr ""

#. Tag: title
#, no-c-format
msgid "A chain of ordered resources expressed as a set"
msgstr ""

#. Tag: programlisting
#, no-c-format
msgid "&lt;constraints&gt;\n"
"    &lt;rsc_order id=\"order-1\"&gt;\n"
"      &lt;resource_set id=\"ordered-set-example\" sequential=\"true\"&gt;\n"
"        &lt;resource_ref id=\"A\"/&gt;\n"
"        &lt;resource_ref id=\"B\"/&gt;\n"
"        &lt;resource_ref id=\"C\"/&gt;\n"
"        &lt;resource_ref id=\"D\"/&gt;\n"
"      &lt;/resource_set&gt;\n"
"    &lt;/rsc_order&gt;\n"
"&lt;/constraints&gt;"
msgstr ""

#. Tag: para
#, no-c-format
msgid "While the set-based format is not less verbose, it is significantly easier to get right and maintain."
msgstr ""

#. Tag: para
#, no-c-format
msgid "If you use a higher-level tool, pay attention to how it exposes this functionality. Depending on the tool, creating a set <literal>A B</literal> may be equivalent to <literal>A then B</literal>, or <literal>B then A</literal>."
msgstr ""

#. Tag: title
#, no-c-format
msgid "Ordering Multiple Sets"
msgstr ""

#. Tag: para
#, no-c-format
msgid "The syntax can be expanded to allow sets of resources to be ordered relative to each other, where the members of each individual set may be ordered or unordered (controlled by the <literal>sequential</literal> property). In the example below, <literal>A</literal> and <literal>B</literal> can both start in parallel, as can <literal>C</literal> and <literal>D</literal>, however <literal>C</literal> and <literal>D</literal> can only start once <emphasis>both</emphasis> <literal>A</literal> <emphasis>and</emphasis> <literal>B</literal> are active."
msgstr ""

#. Tag: title
#, no-c-format
msgid "Ordered sets of unordered resources"
msgstr ""

#. Tag: programlisting
#, no-c-format
msgid "&lt;constraints&gt;\n"
"    &lt;rsc_order id=\"order-1\"&gt;\n"
"      &lt;resource_set id=\"ordered-set-1\" sequential=\"false\"&gt;\n"
"        &lt;resource_ref id=\"A\"/&gt;\n"
"        &lt;resource_ref id=\"B\"/&gt;\n"
"      &lt;/resource_set&gt;\n"
"      &lt;resource_set id=\"ordered-set-2\" sequential=\"false\"&gt;\n"
"        &lt;resource_ref id=\"C\"/&gt;\n"
"        &lt;resource_ref id=\"D\"/&gt;\n"
"      &lt;/resource_set&gt;\n"
"    &lt;/rsc_order&gt;\n"
"  &lt;/constraints&gt;"
msgstr ""

#. Tag: title
#, no-c-format
msgid "Visual representation of the start order for two ordered sets of unordered resources"
msgstr ""

#. Tag: para
#, no-c-format
msgid "Of course either set — or both sets — of resources can also be internally ordered (by setting <literal>sequential=\"true\"</literal>) and there is no limit to the number of sets that can be specified."
msgstr ""

#. Tag: title
#, no-c-format
msgid "Advanced use of set ordering - Three ordered sets, two of which are internally unordered"
msgstr ""

#. Tag: programlisting
#, no-c-format
msgid "&lt;constraints&gt;\n"
"    &lt;rsc_order id=\"order-1\"&gt;\n"
"      &lt;resource_set id=\"ordered-set-1\" sequential=\"false\"&gt;\n"
"        &lt;resource_ref id=\"A\"/&gt;\n"
"        &lt;resource_ref id=\"B\"/&gt;\n"
"      &lt;/resource_set&gt;\n"
"      &lt;resource_set id=\"ordered-set-2\" sequential=\"true\"&gt;\n"
"        &lt;resource_ref id=\"C\"/&gt;\n"
"        &lt;resource_ref id=\"D\"/&gt;\n"
"      &lt;/resource_set&gt;\n"
"      &lt;resource_set id=\"ordered-set-3\" sequential=\"false\"&gt;\n"
"        &lt;resource_ref id=\"E\"/&gt;\n"
"        &lt;resource_ref id=\"F\"/&gt;\n"
"      &lt;/resource_set&gt;\n"
"    &lt;/rsc_order&gt;\n"
"&lt;/constraints&gt;"
msgstr ""

#. Tag: title
#, no-c-format
msgid "Visual representation of the start order for the three sets defined above"
msgstr ""

#. Tag: para
#, no-c-format
msgid "An ordered set with <literal>sequential=false</literal> makes sense only if there is another set in the constraint. Otherwise, the constraint has no effect."
msgstr ""

#. Tag: title
#, no-c-format
msgid "Resource Set OR Logic"
msgstr ""

#. Tag: para
#, no-c-format
msgid "The unordered set logic discussed so far has all been \"AND\" logic. To illustrate this take the 3 resource set figure in the previous section. Those sets can be expressed, <literal>(A and B) then (C) then (D) then (E and F)</literal>."
msgstr ""

#. Tag: para
#, no-c-format
msgid "Say for example we want to change the first set, <literal>(A and B)</literal>, to use \"OR\" logic so the sets look like this: <literal>(A or B) then (C) then (D) then (E and F)</literal>. This functionality can be achieved through the use of the <literal>require-all</literal> option. This option defaults to TRUE which is why the \"AND\" logic is used by default. Setting <literal>require-all=false</literal> means only one resource in the set needs to be started before continuing on to the next set."
msgstr ""

#. Tag: title
#, no-c-format
msgid "Resource Set \"OR\" logic: Three ordered sets, where the first set is internally unordered with \"OR\" logic"
msgstr ""

#. Tag: programlisting
#, no-c-format
msgid "&lt;constraints&gt;\n"
"    &lt;rsc_order id=\"order-1\"&gt;\n"
"      &lt;resource_set id=\"ordered-set-1\" sequential=\"false\" require-all=\"false\"&gt;\n"
"        &lt;resource_ref id=\"A\"/&gt;\n"
"        &lt;resource_ref id=\"B\"/&gt;\n"
"      &lt;/resource_set&gt;\n"
"      &lt;resource_set id=\"ordered-set-2\" sequential=\"true\"&gt;\n"
"        &lt;resource_ref id=\"C\"/&gt;\n"
"        &lt;resource_ref id=\"D\"/&gt;\n"
"      &lt;/resource_set&gt;\n"
"      &lt;resource_set id=\"ordered-set-3\" sequential=\"false\"&gt;\n"
"        &lt;resource_ref id=\"E\"/&gt;\n"
"        &lt;resource_ref id=\"F\"/&gt;\n"
"      &lt;/resource_set&gt;\n"
"    &lt;/rsc_order&gt;\n"
"&lt;/constraints&gt;"
msgstr ""

#. Tag: para
#, no-c-format
msgid "An ordered set with <literal>require-all=false</literal> makes sense only in conjunction with <literal>sequential=false</literal>. Think of it like this: <literal>sequential=false</literal> modifies the set to be an unordered set using \"AND\" logic by default, and adding <literal>require-all=false</literal> flips the unordered set’s \"AND\" logic to \"OR\" logic."
msgstr ""

#. Tag: title
#, no-c-format
msgid "Colocating Sets of Resources"
msgstr ""

#. Tag: para
#, no-c-format
msgid "Another common situation is for an administrator to create a set of colocated resources."
msgstr ""

#. Tag: para
#, no-c-format
msgid "One way to do this would be to define a resource group (see <xref linkend=\"group-resources\" />), but that cannot always accurately express the desired state."
msgstr ""

#. Tag: para
#, no-c-format
msgid "Another way would be to define each relationship as an individual constraint, but that causes a constraint explosion as the number of resources and combinations grow. An example of this approach:"
msgstr ""

#. Tag: title
#, no-c-format
msgid "Chain of colocated resources"
msgstr ""

#. Tag: programlisting
#, no-c-format
msgid "&lt;constraints&gt;\n"
"    &lt;rsc_colocation id=\"coloc-1\" rsc=\"D\" with-rsc=\"C\" score=\"INFINITY\"/&gt;\n"
"    &lt;rsc_colocation id=\"coloc-2\" rsc=\"C\" with-rsc=\"B\" score=\"INFINITY\"/&gt;\n"
"    &lt;rsc_colocation id=\"coloc-3\" rsc=\"B\" with-rsc=\"A\" score=\"INFINITY\"/&gt;\n"
"&lt;/constraints&gt;"
msgstr ""

#. Tag: para
#, no-c-format
msgid "To make things easier, resource sets (see <xref linkend=\"s-resource-sets\" />) can be used within colocation constraints. As with the chained version, a resource that can’t be active prevents any resource that must be colocated with it from being active. For example, if <literal>B</literal> is not able to run, then both <literal>C</literal> and by inference <literal>D</literal> must also remain stopped. Here is an example <literal>resource_set</literal>:"
msgstr ""

#. Tag: title
#, no-c-format
msgid "Equivalent colocation chain expressed using <literal>resource_set</literal>"
msgstr ""

#. Tag: programlisting
#, no-c-format
msgid "&lt;constraints&gt;\n"
"    &lt;rsc_colocation id=\"coloc-1\" score=\"INFINITY\" &gt;\n"
"      &lt;resource_set id=\"colocated-set-example\" sequential=\"true\"&gt;\n"
"        &lt;resource_ref id=\"A\"/&gt;\n"
"        &lt;resource_ref id=\"B\"/&gt;\n"
"        &lt;resource_ref id=\"C\"/&gt;\n"
"        &lt;resource_ref id=\"D\"/&gt;\n"
"      &lt;/resource_set&gt;\n"
"    &lt;/rsc_colocation&gt;\n"
"&lt;/constraints&gt;"
msgstr ""

#. Tag: para
#, no-c-format
msgid "If you use a higher-level tool, pay attention to how it exposes this functionality. Depending on the tool, creating a set <literal>A B</literal> may be equivalent to <literal>A with B</literal>, or <literal>B with A</literal>."
msgstr ""

#. Tag: para
#, no-c-format
msgid "This notation can also be used to tell the cluster that sets of resources must be colocated relative to each other, where the individual members of each set may or may not depend on each other being active (controlled by the <literal>sequential</literal> property)."
msgstr ""

#. Tag: para
#, no-c-format
msgid "In this example, <literal>A</literal>, <literal>B</literal>, and <literal>C</literal> will each be colocated with <literal>D</literal>. <literal>D</literal> must be active, but any of <literal>A</literal>, <literal>B</literal>, or <literal>C</literal> may be inactive without affecting any other resources."
msgstr ""

#. Tag: title
#, no-c-format
msgid "Using colocated sets to specify a common peer"
msgstr ""

#. Tag: programlisting
#, no-c-format
msgid "&lt;constraints&gt;\n"
"    &lt;rsc_colocation id=\"coloc-1\" score=\"INFINITY\" &gt;\n"
"      &lt;resource_set id=\"colocated-set-1\" sequential=\"false\"&gt;\n"
"        &lt;resource_ref id=\"A\"/&gt;\n"
"        &lt;resource_ref id=\"B\"/&gt;\n"
"        &lt;resource_ref id=\"C\"/&gt;\n"
"      &lt;/resource_set&gt;\n"
"      &lt;resource_set id=\"colocated-set-2\" sequential=\"true\"&gt;\n"
"        &lt;resource_ref id=\"D\"/&gt;\n"
"      &lt;/resource_set&gt;\n"
"    &lt;/rsc_colocation&gt;\n"
"&lt;/constraints&gt;"
msgstr ""

#. Tag: para
#, no-c-format
msgid "A colocated set with <literal>sequential=false</literal> makes sense only if there is another set in the constraint. Otherwise, the constraint has no effect."
msgstr ""

#. Tag: para
#, no-c-format
msgid "There is no inherent limit to the number and size of the sets used. The only thing that matters is that in order for any member of one set in the constraint to be active, all members of sets listed after it must also be active (and naturally on the same node); and if a set has <literal>sequential=\"true\"</literal>, then in order for one member of that set to be active, all members listed before it must also be active."
msgstr ""

#. Tag: para
#, no-c-format
msgid "If desired, you can restrict the dependency to instances of promotable clone resources that are in a specific role, using the set’s <literal>role</literal> property."
msgstr ""

#. Tag: title
#, no-c-format
msgid "Colocation chain in which the members of the middle set have no interdependencies, and the last listed set (which the cluster places first) is restricted to instances in master status."
msgstr ""

#. Tag: programlisting
#, no-c-format
msgid "&lt;constraints&gt;\n"
"    &lt;rsc_colocation id=\"coloc-1\" score=\"INFINITY\" &gt;\n"
"      &lt;resource_set id=\"colocated-set-1\" sequential=\"true\"&gt;\n"
"        &lt;resource_ref id=\"B\"/&gt;\n"
"        &lt;resource_ref id=\"A\"/&gt;\n"
"      &lt;/resource_set&gt;\n"
"      &lt;resource_set id=\"colocated-set-2\" sequential=\"false\"&gt;\n"
"        &lt;resource_ref id=\"C\"/&gt;\n"
"        &lt;resource_ref id=\"D\"/&gt;\n"
"        &lt;resource_ref id=\"E\"/&gt;\n"
"      &lt;/resource_set&gt;\n"
"      &lt;resource_set id=\"colocated-set-3\" sequential=\"true\" role=\"Master\"&gt;\n"
"        &lt;resource_ref id=\"G\"/&gt;\n"
"        &lt;resource_ref id=\"F\"/&gt;\n"
"      &lt;/resource_set&gt;\n"
"    &lt;/rsc_colocation&gt;\n"
"&lt;/constraints&gt;"
msgstr ""

#. Tag: title
#, no-c-format
msgid "Visual representation the above example (resources to the left are placed first)"
msgstr ""

#. Tag: para
#, no-c-format
msgid "Pay close attention to the order in which resources and sets are listed. While the colocation dependency for members of any one set is last-to-first, the colocation dependency for multiple sets is first-to-last. In the above example, <literal>B</literal> is colocated with <literal>A</literal>, but <literal>colocated-set-1</literal> is colocated with <literal>colocated-set-2</literal>."
msgstr ""

#. Tag: para
#, no-c-format
msgid "Unlike ordered sets, colocated sets do not use the <literal>require-all</literal> option."
msgstr ""

